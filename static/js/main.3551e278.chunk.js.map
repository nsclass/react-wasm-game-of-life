{"version":3,"sources":["components/UseAnimationFrame.js","components/Renderer.js","App.js","serviceWorker.js","index.js"],"names":["useAnimationFrame","callback","requestRef","React","useRef","previousTimeRef","animate","time","undefined","current","deltaTime","requestAnimationFrame","useEffect","cancelAnimationFrame","Renderer","universe","wasmMemory","useState","setNeedsDraw","canvasRef","width","canvasWidth","height","canvasHeight","getIndex","row","column","ctx","getContext","beginPath","strokeStyle","i","moveTo","lineTo","j","stroke","drawGrid","cellsPtr","cells","Uint8Array","memory","buffer","col","idx","fillStyle","fillRect","drawCells","tick","id","ref","App","loading","setLoading","setUniverse","setWasmMemory","a","console","log","wasm","Universe","new","error","message","loadWasm","className","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch"],"mappings":"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","file":"static/js/main.3551e278.chunk.js","sourcesContent":["import React from \"react\"\n\nconst useAnimationFrame = (callback) => {\n  // Use useRef for mutable variables that we want to persist\n  // without triggering a re-render on their change\n  const requestRef = React.useRef()\n  const previousTimeRef = React.useRef()\n\n  const animate = (time) => {\n    if (previousTimeRef.current !== undefined) {\n      const deltaTime = time - previousTimeRef.current\n      callback(deltaTime)\n    }\n    previousTimeRef.current = time\n    requestRef.current = requestAnimationFrame(animate)\n  }\n\n  React.useEffect(() => {\n    requestRef.current = requestAnimationFrame(animate)\n    return () => cancelAnimationFrame(requestRef.current)\n  }, []) // Make sure the effect runs only once\n}\n\nexport default useAnimationFrame\n","import React, { useState } from \"react\"\nimport useAnimationFrame from \"./UseAnimationFrame\"\n\nconst CELL_SIZE = 5 // px\nconst GRID_COLOR = \"#CCCCCC\"\nconst DEAD_COLOR = \"#FFFFFF\"\nconst ALIVE_COLOR = \"#000000\"\n\nconst Renderer = ({ universe, wasmMemory }) => {\n  // const [scene, setScene] = useState(\"\")\n  const [needsDraw, setNeedsDraw] = useState(false)\n  const canvasRef = React.useRef(null)\n\n  const [canvasWidth, setCanvasWidth] = useState((CELL_SIZE + 1) * universe.width() + 1)\n  const [canvasHeight, setCanvasHeight] = useState((CELL_SIZE + 1) * universe.height() + 1)\n\n  const drawGrid = (ctx) => {\n    const width = universe.width()\n    const height = universe.height()\n\n    ctx.beginPath()\n    ctx.strokeStyle = GRID_COLOR\n\n    // Vertical lines.\n    for (let i = 0; i <= width; i++) {\n      ctx.moveTo(i * (CELL_SIZE + 1) + 1, 0)\n      ctx.lineTo(i * (CELL_SIZE + 1) + 1, (CELL_SIZE + 1) * height + 1)\n    }\n\n    // Horizontal lines.\n    for (let j = 0; j <= height; j++) {\n      ctx.moveTo(0, j * (CELL_SIZE + 1) + 1)\n      ctx.lineTo((CELL_SIZE + 1) * width + 1, j * (CELL_SIZE + 1) + 1)\n    }\n\n    ctx.stroke()\n  }\n\n  const getIndex = (row, column) => {\n    const width = universe.width()\n    return row * width + column\n  }\n\n  const drawCells = (ctx) => {\n    const width = universe.width()\n    const height = universe.height()\n\n    const cellsPtr = universe.cells()\n    const cells = new Uint8Array(wasmMemory.memory.buffer, cellsPtr, width * height)\n\n    ctx.beginPath()\n\n    for (let row = 0; row < height; row++) {\n      for (let col = 0; col < width; col++) {\n        const idx = getIndex(row, col)\n\n        ctx.fillStyle = cells[idx] === 0 ? DEAD_COLOR : ALIVE_COLOR\n\n        ctx.fillRect(col * (CELL_SIZE + 1) + 1, row * (CELL_SIZE + 1) + 1, CELL_SIZE, CELL_SIZE)\n      }\n    }\n\n    ctx.stroke()\n  }\n\n  React.useEffect(() => {\n    const canvas = canvasRef.current\n    const ctx = canvas.getContext(\"2d\")\n    drawGrid(ctx)\n    drawCells(ctx)\n    setNeedsDraw(false)\n  })\n\n  useAnimationFrame((deltaTime) => {\n    universe.tick()\n    setNeedsDraw(true)\n  })\n\n  return (\n    <div>\n      <canvas id=\"game-of-life-canvas\" ref={canvasRef} width={canvasWidth} height={canvasHeight} />\n    </div>\n  )\n}\n\nexport default Renderer\n","import React, { useState } from \"react\"\nimport \"./App.css\"\nimport Renderer from \"./components/Renderer\"\n\nconst App = () => {\n  const [loading, setLoading] = useState(false)\n  const [universe, setUniverse] = useState(null)\n  const [wasmMemory, setWasmMemory] = useState(null)\n\n  const loadWasm = async () => {\n    try {\n      setLoading(true)\n      console.log(\"loading...\")\n      const wasm = await import(\"wasm-game-of-life\")\n      setUniverse(wasm.Universe.new())\n\n      const memory = await import(\"wasm-game-of-life/wasm_game_of_life_bg\")\n      setWasmMemory(memory)\n    } catch (err) {\n      console.error(`Unexpected error in loadWasm. [Message: ${err.message}]`)\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  if (!universe && !loading) {\n    loadWasm()\n  }\n\n  if (!universe || !wasmMemory) {\n    return (\n      <div className=\"container\">\n        <h1 className=\"title\">loading...</h1>\n      </div>\n    )\n  }\n\n  return <Renderer universe={universe} wasmMemory={wasmMemory} />\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}